// Constrain this_rhs to have actually been this_x or 1
let (this_rhs_sub_x, this_rhs_sub_1) = if circuit.prover() {

} else { (None, None) };
let this_rhs_sub_x = circuit.add_secret_input(this_rhs_sub_x);
let this_rhs_sub_1 = circuit.add_secret_input(this_rhs_sub_1);
let ((sub_x, sub_1, zero), _) = circuit.product(this_rhs_sub_x, this_rhs_sub_1);

let mut constraint = Constraint::new("this_x_or_1_left");
constraint.weight(this_rhs, Self::F::ONE);
constraint.weight(this_x, -Self::F::ONE);
constraint.weight(sub_x, -Self::F::ONE);
circuit.constrain(constraint);

let mut constraint = Constraint::new("this_x_or_1_right");
constraint.weight(this_rhs, Self::F::ONE);
constraint.weight(sub_1, -Self::F::ONE);
constraint.rhs_offset(Self::F::ONE);
circuit.constrain(constraint);

let mut constraint = Constraint::new("this_x_or_1_out")
constraint.weight(zero, Self::F::ONE);
circuit.constrain(constraint);
